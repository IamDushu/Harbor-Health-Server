// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: provider.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const checkProviderAvailability = `-- name: CheckProviderAvailability :one
SELECT EXISTS (
    SELECT 1 FROM provider_availability
    WHERE provider_id = $1 
    AND day_of_week = $2 
    AND start_time::text = $3
) AS exists
`

type CheckProviderAvailabilityParams struct {
	ProviderID uuid.UUID `json:"provider_id"`
	DayOfWeek  int32     `json:"day_of_week"`
	StartTime  time.Time `json:"start_time"`
}

func (q *Queries) CheckProviderAvailability(ctx context.Context, arg CheckProviderAvailabilityParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProviderAvailability, arg.ProviderID, arg.DayOfWeek, arg.StartTime)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAvailableSlotsForProvider = `-- name: GetAvailableSlotsForProvider :many
SELECT pa.day_of_week, pa.start_time, pa.end_time
FROM provider_availability pa
WHERE pa.provider_id = $1
  AND pa.day_of_week = $2
  AND NOT EXISTS (
    SELECT 1
    FROM visits v
    WHERE v.provider_id = pa.provider_id
      AND v.scheduled_at::DATE = $3  
      AND v.scheduled_at::TIME = pa.start_time  
  )
`

type GetAvailableSlotsForProviderParams struct {
	ProviderID  uuid.UUID `json:"provider_id"`
	DayOfWeek   int32     `json:"day_of_week"`
	ScheduledAt time.Time `json:"scheduled_at"`
}

type GetAvailableSlotsForProviderRow struct {
	DayOfWeek int32     `json:"day_of_week"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

func (q *Queries) GetAvailableSlotsForProvider(ctx context.Context, arg GetAvailableSlotsForProviderParams) ([]GetAvailableSlotsForProviderRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableSlotsForProvider, arg.ProviderID, arg.DayOfWeek, arg.ScheduledAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableSlotsForProviderRow{}
	for rows.Next() {
		var i GetAvailableSlotsForProviderRow
		if err := rows.Scan(&i.DayOfWeek, &i.StartTime, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvidersFromLocation = `-- name: GetProvidersFromLocation :many
SELECT 
    p.provider_id,
    u.first_name,
    u.last_name,
    p.credentials,
    p.specialization
FROM 
    provider_locations pl
JOIN 
    providers p ON pl.provider_id = p.provider_id
JOIN 
    users u ON p.user_id = u.user_id
WHERE 
    pl.location_id = $1
    AND p.is_available = true
`

type GetProvidersFromLocationRow struct {
	ProviderID     uuid.UUID `json:"provider_id"`
	FirstName      string    `json:"first_name"`
	LastName       string    `json:"last_name"`
	Credentials    string    `json:"credentials"`
	Specialization string    `json:"specialization"`
}

func (q *Queries) GetProvidersFromLocation(ctx context.Context, locationID uuid.UUID) ([]GetProvidersFromLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, getProvidersFromLocation, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProvidersFromLocationRow{}
	for rows.Next() {
		var i GetProvidersFromLocationRow
		if err := rows.Scan(
			&i.ProviderID,
			&i.FirstName,
			&i.LastName,
			&i.Credentials,
			&i.Specialization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
